generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ========================================
// USERS & AUTHENTICATION
// ========================================

enum UserRole {
  ADMIN
  COMMERCIAL
  DELIVERY
  CLIENT
  ACCOUNTANT
  STAFF_PREPA  // Preparation and reception staff
  SUB_ADMIN    // Supervisor - can validate tasks and view all operations
}

enum UserStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
}

model User {
  id          String     @id @default(uuid())
  email       String     @unique
  password    String
  firstName   String?
  lastName    String?
  phone       String?
  avatar      String?
  role        UserRole   @default(CLIENT)
  status      UserStatus @default(ACTIVE)
  permissions Json? // Section-level permissions: {"dashboard": true, "customers": false, ...}

  // Horaires de travail (informatifs)
  workStartTime String? // Format "09:00"
  workEndTime   String? // Format "18:00"
  workDays      String[] @default([]) // ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"]
  timezone      String?  @default("Europe/Paris")

  // Tracking de connexion
  isOnline         Boolean   @default(false)
  lastSeenAt       DateTime?
  currentSessionId String?

  // Relations
  customers       Customer[]       @relation("UserCustomers")
  orders          Order[]
  quotes          Quote[]
  invoices        Invoice[]
  gpsTrackings    GpsTracking[]
  activities      Activity[]
  importHistory   ImportHistory[]
  userPermissions UserPermission[]
  connectionLogs  ConnectionLog[]
  creditNotes     CreditNote[]
  bankConnections BankConnection[] // Synchronisation bancaire
  trips           Trip[] // Trajets commerciaux

  // Relations delivery/courier system
  salesDeliveries      Delivery[]        @relation("DeliverySales")
  courierDeliveries    Delivery[]        @relation("DeliveryCourier")
  deliveryEvents       DeliveryEvent[]   @relation("DeliveryEventUser")
  courierProfile       CourierProfile?   @relation("CourierProfileUser")
  courierLocations     CourierLocation[] @relation("CourierLocationUser")
  notifications        Notification[]    @relation("NotificationUser")
  payouts              Payout[]          @relation("PayoutCourier")

  // Relations logistics/tasks system
  tasksAssigned      Task[]       @relation("TaskAssignedTo")    // Tasks assigned to this user
  tasksCreated       Task[]       @relation("TaskAssignedBy")    // Tasks assigned by this user
  taskProofsUploaded TaskProof[]  @relation("TaskProofUploadedBy")
  taskReviews        TaskReview[] @relation("TaskReviewedBy")    // Reviews made by this user (SUB_ADMIN)

  // Metadata
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  lastLoginAt DateTime?

  @@map("users")
}

// Historique des connexions
model ConnectionLog {
  id        String    @id @default(uuid())
  userId    String
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  sessionId String    @unique
  loginAt   DateTime  @default(now())
  logoutAt  DateTime?
  ipAddress String?
  userAgent String?
  duration  Int? // Durée en secondes

  @@index([userId])
  @@index([loginAt])
  @@map("connection_logs")
}

// ========================================
// CRM - CUSTOMERS
// ========================================

enum CustomerType {
  INDIVIDUAL
  COMPANY
}

enum CustomerStatus {
  PROSPECT
  ACTIVE
  INACTIVE
  BLOCKED
}

model Customer {
  id     String         @id @default(uuid())
  type   CustomerType   @default(INDIVIDUAL)
  status CustomerStatus @default(PROSPECT)

  // Individual fields
  firstName String?
  lastName  String?

  // Company fields
  companyName String?
  siret       String?
  vatNumber   String?

  // Authentication
  password String? // Mot de passe hashé (nullable pour compatibilité avec clients existants)

  // Contact
  email    String  @unique
  phone    String?
  mobile   String?
  phone2   String? // Téléphone secondaire
  fax      String?
  whatsapp String?

  // Address
  address      String?
  addressLine2 String?
  city         String?
  postalCode   String?
  country      String? @default("France")
  latitude     Float? // Latitude GPS pour affichage sur carte
  longitude    Float? // Longitude GPS pour affichage sur carte

  // Commercial
  userId String
  user   User   @relation("UserCustomers", fields: [userId], references: [id], onDelete: Cascade)

  // Remises commerciales (appliquées par le commercial)
  discountRate      Float?   @default(0) // Taux de remise en pourcentage (ex: 10 pour 10%)
  discountType      String?  @default("PERCENTAGE") // "PERCENTAGE" ou "FIXED"
  discountReason    String? // Raison de la remise
  discountValidFrom DateTime? // Date de début de validité
  discountValidTo   DateTime? // Date de fin de validité
  discountAppliedBy String? // ID du commercial qui a appliqué la remise

  // Relations
  orders            Order[]
  quotes            Quote[]
  invoices          Invoice[]
  activities        Activity[]
  reviews           Review[]
  accountingEntries AccountingEntry[]
  visits            Visit[] // Visites commerciales
  deliveries        Delivery[] // Livraisons pour ce client

  // Notes & Tags
  notes String?
  tags  String[]

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("customers")
}

// ========================================
// SUPPLIERS (Fournisseurs)
// ========================================

enum SupplierStatus {
  ACTIVE
  INACTIVE
  BLOCKED
}

model Supplier {
  id String @id @default(uuid())

  // Company Info
  companyName   String
  contactPerson String?
  siret         String?
  vatNumber     String?

  // Contact
  email   String  @unique
  phone   String?
  mobile  String?
  website String?

  // Address
  address      String?
  addressLine2 String?
  city         String?
  postalCode   String?
  country      String? @default("France")

  // Status
  status SupplierStatus @default(ACTIVE)

  // Payment Terms
  paymentTerms  String? // e.g., "30 jours fin de mois"
  paymentMethod String? // e.g., "Virement", "Chèque"

  // Relations
  products          Product[]
  purchaseInvoices  PurchaseInvoice[]
  accountingEntries AccountingEntry[]

  // Notes
  notes String?
  tags  String[]

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("suppliers")
}

// ========================================
// PRODUCTS & INVENTORY
// ========================================

enum ProductStatus {
  ACTIVE
  INACTIVE
  OUT_OF_STOCK
}

enum AvailabilityStatus {
  AVAILABLE // Disponible (vert)
  UNAVAILABLE // Non disponible (rouge)
  INCOMING // En cours d'arrivage (jaune)
}

model Category {
  id          String     @id @default(uuid())
  name        String
  slug        String     @unique
  description String?
  image       String?
  isVisible   Boolean    @default(true)
  parentId    String?
  parent      Category?  @relation("CategoryHierarchy", fields: [parentId], references: [id])
  children    Category[] @relation("CategoryHierarchy")
  products    Product[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("categories")
}

model Product {
  id               String  @id @default(uuid())
  sku              String  @unique
  barcode          String? @unique
  name             String
  slug             String  @unique
  description      String?
  shortDescription String?

  // Pricing
  price          Float
  costPrice      Float?
  compareAtPrice Float?

  // Stock
  stock    Int  @default(0)
  minStock Int? @default(5)
  maxStock Int?

  // Status
  status             ProductStatus      @default(ACTIVE)
  availabilityStatus AvailabilityStatus @default(AVAILABLE)
  isVisible          Boolean            @default(true)
  isFeatured         Boolean            @default(false)

  // Media
  images    String[]
  thumbnail String?

  // Category (OBLIGATOIRE - un produit doit toujours avoir une catégorie)
  categoryId String
  category   Category @relation(fields: [categoryId], references: [id])

  // Supplier
  supplierId String?
  supplier   Supplier? @relation(fields: [supplierId], references: [id])

  // Dimensions & Shipping
  weight Float?
  width  Float?
  height Float?
  length Float?

  // Relations
  orderItems           OrderItem[]
  quoteItems           QuoteItem[]
  invoiceItems         InvoiceItem[]
  creditNoteItems      CreditNoteItem[]
  purchaseInvoiceItems PurchaseInvoiceItem[]
  stockMovements       StockMovement[]
  reviews              Review[]

  // SEO
  metaTitle       String?
  metaDescription String?
  metaKeywords    String[]

  // Tags
  tags String[]

  // Champ lexical pour recherche intelligente
  searchTerms String[] @default([])

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("products")
}

// ========================================
// QUOTES (Devis)
// ========================================

enum QuoteStatus {
  DRAFT
  SENT
  ACCEPTED
  REJECTED
  EXPIRED
}

model Quote {
  id     String @id @default(uuid())
  number String @unique

  // Customer
  customerId String
  customer   Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)

  // Commercial
  userId String
  user   User   @relation(fields: [userId], references: [id])

  // Status
  status QuoteStatus @default(DRAFT)

  // Items
  items QuoteItem[]

  // Amounts
  subtotal  Float @default(0)
  taxAmount Float @default(0)
  discount  Float @default(0)
  total     Float @default(0)

  // Dates
  validUntil DateTime?
  sentAt     DateTime?
  acceptedAt DateTime?

  // Notes
  notes           String?
  termsConditions String?

  // PDF
  pdfUrl String?

  // GPS Location when created
  gpsLatitude  Float?
  gpsLongitude Float?
  gpsAddress   String?

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("quotes")
}

model QuoteItem {
  id      String @id @default(uuid())
  quoteId String
  quote   Quote  @relation(fields: [quoteId], references: [id], onDelete: Cascade)

  productId String
  product   Product @relation(fields: [productId], references: [id])

  quantity  Int
  unitPrice Float
  taxRate   Float @default(20)
  discount  Float @default(0)
  total     Float

  createdAt DateTime @default(now())

  @@map("quote_items")
}

// ========================================
// ORDERS (Commandes)
// ========================================

enum OrderStatus {
  PENDING
  CONFIRMED
  PROCESSING
  SHIPPED
  DELIVERED
  CANCELLED
}

enum PaymentStatus {
  PENDING
  PAID
  PARTIAL
  REFUNDED
  FAILED
}

model Order {
  id     String @id @default(uuid())
  number String @unique

  // Customer
  customerId String
  customer   Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)

  // Commercial
  userId String
  user   User   @relation(fields: [userId], references: [id])

  // Status
  status        OrderStatus   @default(PENDING)
  paymentStatus PaymentStatus @default(PENDING)

  // Items
  items OrderItem[]

  // Amounts
  subtotal     Float @default(0)
  taxAmount    Float @default(0)
  shippingCost Float @default(0)
  discount     Float @default(0)
  total        Float @default(0)

  // Shipping Address
  shippingAddress    String?
  shippingCity       String?
  shippingPostalCode String?
  shippingCountry    String?

  // Notes
  notes        String?
  customerNote String?

  // Payments
  payments Payment[]

  // Invoice
  invoice Invoice?

  // Delivery (système de livraison coursier)
  deliveries Delivery[]

  // PDF Documents
  orderPdfUrl        String?
  deliveryNotePdfUrl String?

  // GPS Location
  gpsLatitude  Float?
  gpsLongitude Float?
  gpsAddress   String?

  // Dates
  confirmedAt DateTime?
  shippedAt   DateTime?
  deliveredAt DateTime?

  // LOGISTICS SYSTEM - Fulfillment Flow
  fulfillmentFlow String? @default("DIRECT") // DIRECT or INBOUND_THEN_LAST_MILE

  // Inbound Logistics (FRANCE → GUADELOUPE)
  inboundCarrier        String?
  inboundTrackingNumber String?
  inboundStatus         String? @default("NOT_STARTED") // NOT_STARTED, SHIPPED, IN_TRANSIT, RECEIVED
  inboundShippedAt      DateTime?
  inboundReceivedAt     DateTime?
  inboundProofUrl       String? // Photo/scan de réception
  inboundNotes          String?

  // Last Mile Delivery (LOCAL DELIVERY in Guadeloupe)
  lastMileType           String? // INTERNAL_DRIVER or EXTERNAL_CARRIER
  lastMileCarrier        String? // If external
  lastMileTrackingNumber String? // If external
  lastMileNotes          String?

  // Relations for logistics
  tasks Task[] // Task/intervention assignments

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("orders")
}

model OrderItem {
  id      String @id @default(uuid())
  orderId String
  order   Order  @relation(fields: [orderId], references: [id], onDelete: Cascade)

  productId String
  product   Product @relation(fields: [productId], references: [id])

  quantity  Int
  unitPrice Float
  taxRate   Float @default(20)
  discount  Float @default(0)
  total     Float

  createdAt DateTime @default(now())

  @@map("order_items")
}

// ========================================
// INVOICES (Factures)
// ========================================

enum InvoiceStatus {
  DRAFT
  SENT
  PAID
  OVERDUE
  CANCELLED
}

model Invoice {
  id     String @id @default(uuid())
  number String @unique

  // Customer
  customerId String
  customer   Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)

  // Commercial
  userId String
  user   User   @relation(fields: [userId], references: [id])

  // Order
  orderId String? @unique
  order   Order?  @relation(fields: [orderId], references: [id])

  // Status
  status InvoiceStatus @default(DRAFT)

  // Items
  items InvoiceItem[]

  // Amounts
  subtotal   Float @default(0)
  tax        Float @default(0)
  taxAmount  Float @default(0)
  discount   Float @default(0)
  total      Float @default(0)
  paidAmount Float @default(0)

  // Accounting
  accountingEntryId String?          @unique
  accountingEntry   AccountingEntry? @relation(fields: [accountingEntryId], references: [id])

  // Dates
  issueDate DateTime  @default(now())
  dueDate   DateTime?
  paidAt    DateTime?

  // Notes
  notes           String?
  termsConditions String?

  // PDF
  pdfUrl String?

  // Payments
  payments Payment[]

  // Credit Notes (Avoirs)
  creditNotes CreditNote[]

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("invoices")
}

model InvoiceItem {
  id        String  @id @default(uuid())
  invoiceId String
  invoice   Invoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  productId String
  product   Product @relation(fields: [productId], references: [id])

  quantity  Int
  unitPrice Float
  taxRate   Float @default(20)
  discount  Float @default(0)
  total     Float

  createdAt DateTime @default(now())

  @@map("invoice_items")
}

// ========================================
// CREDIT NOTES (AVOIRS)
// ========================================

enum CreditNoteType {
  TOTAL    // Avoir total (annule toute la facture)
  PARTIAL  // Avoir partiel (annule certains produits)
}

model CreditNote {
  id        String          @id @default(uuid())
  number    String          @unique // Ex: AV-2024-001
  type      CreditNoteType  @default(TOTAL)
  reason    String?         // Motif de l'avoir

  // Relation avec la facture d'origine
  invoiceId String
  invoice   Invoice         @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  // Commercial qui a créé l'avoir
  userId    String
  user      User            @relation(fields: [userId], references: [id])

  // Items concernés par l'avoir
  items     CreditNoteItem[]

  // Montants
  subtotal   Float          @default(0)
  taxAmount  Float          @default(0)
  total      Float          @default(0)

  // Notes
  notes      String?

  // PDF
  pdfUrl     String?

  // Metadata
  createdAt  DateTime       @default(now())
  updatedAt  DateTime       @updatedAt

  @@map("credit_notes")
}

model CreditNoteItem {
  id            String      @id @default(uuid())
  creditNoteId  String
  creditNote    CreditNote  @relation(fields: [creditNoteId], references: [id], onDelete: Cascade)

  productId     String
  product       Product     @relation(fields: [productId], references: [id])

  quantity      Int
  unitPrice     Float
  taxRate       Float       @default(20)
  discount      Float       @default(0)
  total         Float

  createdAt     DateTime    @default(now())

  @@map("credit_note_items")
}

// ========================================
// PAYMENTS
// ========================================

enum PaymentMethod {
  CREDIT_CARD
  STRIPE
  PAYPAL
  PAYLIB
  BANK_TRANSFER
  CASH
  CHECK
}

enum PaymentStatusEnum {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
  CANCELLED
}

model Payment {
  id String @id @default(uuid())

  // Order or Invoice
  orderId String?
  order   Order?  @relation(fields: [orderId], references: [id])

  invoiceId String?
  invoice   Invoice? @relation(fields: [invoiceId], references: [id])

  // Payment details
  amount Float
  method PaymentMethod
  status PaymentStatusEnum @default(PENDING)

  // External references
  transactionId   String?
  stripePaymentId String?
  paypalOrderId   String?

  // Metadata
  metadata Json?
  notes    String?

  // Dates
  paidAt     DateTime?
  refundedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("payments")
}

// ========================================
// GPS TRACKING
// ========================================

enum ActionType {
  CUSTOMER_VISIT
  QUOTE_CREATED
  ORDER_CREATED
  DELIVERY
  MEETING
  PHONE_CALL
  OTHER
}

model GpsTracking {
  id String @id @default(uuid())

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  actionType ActionType

  // GPS Coordinates
  latitude  Float
  longitude Float
  accuracy  Float?
  address   String?

  // Related entities
  customerId String?
  orderId    String?
  quoteId    String?

  // Notes
  notes String?

  // Metadata
  timestamp DateTime @default(now())
  createdAt DateTime @default(now())

  @@map("gps_trackings")
}

// ========================================
// ACTIVITY LOG
// ========================================

enum ActivityType {
  CUSTOMER_CREATED
  CUSTOMER_UPDATED
  QUOTE_CREATED
  QUOTE_SENT
  QUOTE_ACCEPTED
  ORDER_CREATED
  ORDER_CONFIRMED
  ORDER_SHIPPED
  ORDER_DELIVERED
  INVOICE_CREATED
  INVOICE_SENT
  INVOICE_PAID
  PAYMENT_RECEIVED
  PRODUCT_CREATED
  PRODUCT_UPDATED
  USER_LOGIN
  OTHER
}

model Activity {
  id String @id @default(uuid())

  type        ActivityType
  description String

  userId String?
  user   User?   @relation(fields: [userId], references: [id])

  customerId String?
  customer   Customer? @relation(fields: [customerId], references: [id])

  metadata Json?

  createdAt DateTime @default(now())

  @@map("activities")
}

// ========================================
// MASS IMPORT
// ========================================

enum ImportStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

enum ImportType {
  PRODUCTS
  CUSTOMERS
  ORDERS
}

model Import {
  id String @id @default(uuid())

  type   ImportType
  status ImportStatus @default(PENDING)

  fileName String
  filePath String

  totalRows     Int @default(0)
  processedRows Int @default(0)
  successRows   Int @default(0)
  failedRows    Int @default(0)

  errors Json?

  startedAt   DateTime?
  completedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("imports")
}

// ========================================
// SETTINGS
// ========================================

model Settings {
  id    String @id @default(uuid())
  key   String @unique
  value String
  type  String @default("string")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("settings")
}

// ========================================
// PURCHASE INVOICES (Factures d'achat)
// ========================================

enum PurchaseInvoiceStatus {
  DRAFT
  VALIDATED
  PAID
  CANCELLED
}

model PurchaseInvoice {
  id     String @id @default(uuid())
  number String @unique

  // Supplier
  supplierId String
  supplier   Supplier @relation(fields: [supplierId], references: [id])

  // Status
  status PurchaseInvoiceStatus @default(DRAFT)

  // Items
  items PurchaseInvoiceItem[]

  // Amounts
  subtotal  Float @default(0)
  tax       Float @default(0)
  taxAmount Float @default(0)
  discount  Float @default(0)
  total     Float @default(0)

  // Dates
  date        DateTime  @default(now())
  invoiceDate DateTime  @default(now())
  dueDate     DateTime?
  paidAt      DateTime?

  // Notes
  notes     String?
  reference String? // Numéro de facture fournisseur

  // PDF
  pdfUrl String?

  // Accounting
  accountingEntryId String?          @unique
  accountingEntry   AccountingEntry? @relation(fields: [accountingEntryId], references: [id])

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("purchase_invoices")
}

model PurchaseInvoiceItem {
  id                String          @id @default(uuid())
  purchaseInvoiceId String
  purchaseInvoice   PurchaseInvoice @relation(fields: [purchaseInvoiceId], references: [id], onDelete: Cascade)

  productId String
  product   Product @relation(fields: [productId], references: [id])

  quantity  Int
  unitPrice Float
  taxRate   Float @default(20)
  discount  Float @default(0)
  total     Float

  createdAt DateTime @default(now())

  @@map("purchase_invoice_items")
}

// ========================================
// STOCK MOVEMENTS (Mouvements de stock)
// ========================================

enum StockMovementType {
  PURCHASE // Achat fournisseur
  SALE // Vente client
  RETURN // Retour
  ADJUSTMENT // Ajustement manuel
  TRANSFER // Transfert
  LOSS // Perte/casse
}

model StockMovement {
  id String @id @default(uuid())

  productId String
  product   Product @relation(fields: [productId], references: [id])

  type        StockMovementType
  quantity    Int // Positif = entrée, Négatif = sortie
  stockBefore Int // Stock avant mouvement
  stockAfter  Int // Stock après mouvement

  // References
  orderId           String?
  purchaseInvoiceId String?
  referenceNumber   String? // Numéro de référence (bon de livraison, etc.)

  // User who made the movement
  userId String?
  notes  String?

  movementDate DateTime @default(now())
  createdAt    DateTime @default(now())

  @@map("stock_movements")
}

// ========================================
// ACCOUNTING (Comptabilité)
// ========================================

enum AccountType {
  ASSET // Classe 1-2 (Actif)
  LIABILITY // Classe 1 (Passif)
  EQUITY // Classe 1 (Capitaux propres)
  REVENUE // Classe 7 (Produits)
  EXPENSE // Classe 6 (Charges)
}

enum JournalType {
  VENTE // Journal des ventes
  ACHAT // Journal des achats
  BANQUE // Journal de banque
  CAISSE // Journal de caisse
  OD // Opérations diverses
}

model AccountingAccount {
  id   String      @id @default(uuid())
  code String      @unique // ex: "401000", "707000"
  name String // ex: "Fournisseurs", "Ventes de marchandises"
  type AccountType

  // Hierarchy
  parentId String?
  parent   AccountingAccount?  @relation("AccountHierarchy", fields: [parentId], references: [id])
  children AccountingAccount[] @relation("AccountHierarchy")

  // Relations
  entryLines   AccountingEntryLine[]
  bankAccounts BankAccount[] // Comptes bancaires mappés à ce compte comptable

  // Metadata
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("accounting_accounts")
}

enum AccountingEntryStatus {
  DRAFT
  VALIDATED
}

model AccountingEntry {
  id      String                @id @default(uuid())
  number  String                @unique
  date    DateTime              @default(now())
  label   String
  journal JournalType
  status  AccountingEntryStatus @default(DRAFT)

  // Relations
  lines AccountingEntryLine[]

  // Source documents
  invoiceId       String?          @unique
  invoice         Invoice?
  purchaseInvoice PurchaseInvoice?

  orderId   String?
  reference String? // Numéro de pièce

  // FEC - Champs obligatoires pour le fichier FEC
  journalCode    String  // VE, AC, BQ, CA, OD, AN (code du journal)
  journalLabel   String  // "Ventes", "Achats", "Banque", etc.
  pieceRef       String? // Référence de la pièce justificative
  pieceDate      DateTime? // Date de la pièce
  validationDate DateTime? // Date de validation de l'écriture

  // FEC - Lettrage (pour rapprochements)
  lettrage     String? // Code de lettrage (ex: "A", "B", "C")
  lettrageDate DateTime? // Date du lettrage

  // FEC - Tiers (client ou fournisseur)
  thirdPartyCode  String? // Code auxiliaire (ex: "C0001", "F0001")
  thirdPartyLabel String? // Nom du tiers
  customerId      String?
  customer        Customer? @relation(fields: [customerId], references: [id])
  supplierId      String?
  supplier        Supplier? @relation(fields: [supplierId], references: [id])

  // Synchronisation bancaire
  bankTransaction BankTransaction? // Lien vers transaction bancaire (si automatique)

  // Metadata
  notes     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("accounting_entries")
}

model AccountingEntryLine {
  id String @id @default(uuid())

  entryId String
  entry   AccountingEntry @relation(fields: [entryId], references: [id], onDelete: Cascade)

  accountId String
  account   AccountingAccount @relation(fields: [accountId], references: [id])

  label  String?
  debit  Float   @default(0)
  credit Float   @default(0)

  // FEC - Devise (pour opérations en devises étrangères)
  amountCurrency Float?  // Montant en devise étrangère
  currency       String? // Code devise ISO (EUR, USD, GBP, etc.)

  createdAt DateTime @default(now())

  @@map("accounting_entry_lines")
}

// ========================================
// IMPORT HISTORY
// ========================================

model ImportHistory {
  id           String @id @default(uuid())
  type         String // CUSTOMERS, PRODUCTS, SUPPLIERS, STOCKS
  totalRows    Int
  successCount Int    @default(0)
  errorCount   Int    @default(0)
  warningCount Int    @default(0)

  userId String
  user   User   @relation(fields: [userId], references: [id])

  errors   String? @db.Text // JSON string
  warnings String? @db.Text // JSON string

  createdAt DateTime @default(now())

  @@map("import_history")
}

// ========================================
// FEC EXPORT HISTORY
// ========================================

model FECExport {
  id       String @id @default(uuid())
  filename String // fec_SIREN_YYYYMMDD_HHMMSS.txt
  siren    String // 9 chiffres

  // Période couverte
  startDate DateTime // Date début période
  endDate   DateTime // Date fin période

  // Format du fichier
  format String @default("txt") // txt ou csv

  // Chemin du fichier généré
  filePath String?

  // Statut de l'export
  status String @default("PENDING") // PENDING, COMPLETED, ERROR

  // Statistiques
  totalEntries Int?   // Nombre d'écritures exportées
  totalLines   Int?   // Nombre de lignes d'écriture
  totalDebit   Float? // Total des débits
  totalCredit  Float? // Total des crédits

  // Métadonnées
  createdBy String?
  createdAt DateTime @default(now())

  @@map("fec_exports")
}

// ========================================
// BANK SYNCHRONIZATION (Synchronisation bancaire style Pennylane)
// ========================================

// Connexion bancaire (Bridge API, Budget Insight, etc.)
model BankConnection {
  id String @id @default(uuid())

  // Utilisateur propriétaire
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Informations banque
  bankName String // "BNP Paribas", "Crédit Agricole", etc.
  bankLogo String? // URL du logo

  // Authentification API
  provider     String // "bridge", "budget_insight", "plaid"
  accessToken  String @db.Text // Token d'accès (chiffré)
  refreshToken String? @db.Text // Token de rafraîchissement
  expiresAt    DateTime?

  // Statut
  status   String    @default("ACTIVE") // ACTIVE, ERROR, DISCONNECTED
  lastSync DateTime?
  nextSync DateTime?

  // Métadonnées
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  accounts BankAccount[]

  @@map("bank_connections")
}

// Compte bancaire
model BankAccount {
  id           String         @id @default(uuid())
  connectionId String
  connection   BankConnection @relation(fields: [connectionId], references: [id], onDelete: Cascade)

  // Informations compte
  accountNumber String // Numéro de compte (masqué: ****1234)
  iban          String? // IBAN complet (chiffré)
  accountName   String // "Compte courant", "Compte épargne"
  accountType   String // "checking", "savings", "credit_card"
  currency      String  @default("EUR")

  // Soldes
  balance     Float // Solde actuel
  balanceDate DateTime // Date du solde

  // Mapping comptable
  accountingAccountId String?
  accountingAccount   AccountingAccount? @relation(fields: [accountingAccountId], references: [id])

  // Statut
  status String @default("ACTIVE")

  // Métadonnées
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  transactions BankTransaction[]

  @@map("bank_accounts")
}

// Transaction bancaire brute
model BankTransaction {
  id            String      @id @default(uuid())
  bankAccountId String
  bankAccount   BankAccount @relation(fields: [bankAccountId], references: [id], onDelete: Cascade)

  // Identifiant unique de la banque
  externalId String // ID fourni par l'API bancaire

  // Informations transaction
  date      DateTime // Date de la transaction
  valueDate DateTime? // Date de valeur
  amount    Float // Montant (négatif = débit, positif = crédit)
  currency  String   @default("EUR")

  // Description
  rawLabel   String  @db.Text // Libellé brut de la banque
  cleanLabel String? @db.Text // Libellé nettoyé (sans codes techniques)
  category   String? // Catégorie détectée par l'IA

  // Contrepartie
  counterparty     String? // Nom du tiers (bénéficiaire/émetteur)
  counterpartyIBAN String? // IBAN de la contrepartie

  // Statut de traitement
  status String @default("PENDING") // PENDING, PROCESSED, IGNORED, ERROR

  // Catégorisation IA
  aiCategoryConfidence Float? // Confiance de l'IA (0-1)
  aiSuggestedAccount   String? // Compte comptable suggéré
  aiSuggestedVAT       Float? // TVA suggérée (20%, 10%, 5.5%, etc.)
  aiReasoning          String? @db.Text // Explication de l'IA

  // Mapping comptable
  accountingEntryId String?          @unique
  accountingEntry   AccountingEntry? @relation(fields: [accountingEntryId], references: [id])

  // Règle appliquée (si automatique)
  ruleId String?
  rule   TransactionRule? @relation(fields: [ruleId], references: [id])

  // Métadonnées
  processedAt DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  // Relations
  reconciliationMatches ReconciliationMatch[]

  @@unique([bankAccountId, externalId])
  @@index([date])
  @@index([status])
  @@map("bank_transactions")
}

// Règles de catégorisation automatique
model TransactionRule {
  id     String @id @default(uuid())
  userId String // Utilisateur propriétaire

  // Conditions de déclenchement
  name        String // Nom de la règle
  description String?
  priority    Int     @default(0) // Ordre d'application (0 = haute priorité)

  // Critères de matching
  matchType  String // "contains", "starts_with", "ends_with", "exact", "regex"
  matchValue String // Valeur à chercher dans le libellé
  matchField String @default("rawLabel") // rawLabel, counterparty, amount

  // Conditions supplémentaires
  minAmount     Float? // Montant minimum
  maxAmount     Float? // Montant maximum
  amountType    String? // "debit", "credit", "both"
  bankAccountId String? // Compte bancaire spécifique

  // Actions à appliquer
  category              String // Catégorie à appliquer
  accountingAccountCode String // Code du compte comptable
  vatRate               Float? // Taux de TVA à appliquer
  journalCode           String // Code journal (VE, AC, BQ, etc.)

  // Tiers
  customerCode String? // Code client automatique
  supplierCode String? // Code fournisseur automatique

  // Auto-validation
  autoValidate Boolean @default(false) // Valider automatiquement l'écriture

  // Statut
  isActive Boolean @default(true)

  // Statistiques
  timesApplied  Int       @default(0)
  lastAppliedAt DateTime?

  // Métadonnées
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  transactions BankTransaction[]

  @@map("transaction_rules")
}

// Rapprochement (matching facture ↔ paiement)
model ReconciliationMatch {
  id            String          @id @default(uuid())
  transactionId String
  transaction   BankTransaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)

  // Document lié (facture, avoir, etc.)
  documentType String // "invoice", "credit_note", "quote", "expense"
  documentId   String // ID du document

  // Montant du rapprochement
  matchedAmount Float // Montant rapproché (peut être partiel)

  // Statut
  status     String @default("MATCHED") // MATCHED, PARTIAL, UNMATCHED
  confidence Float // Confiance du matching (0-1)

  // IA
  isAutomatic Boolean @default(false) // Matching automatique ou manuel
  aiReasoning String? @db.Text // Explication de l'IA

  // Validation
  validatedBy String? // ID utilisateur qui a validé
  validatedAt DateTime?

  // Métadonnées
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("reconciliation_matches")
}

// Historique de synchronisation
model SyncHistory {
  id           String @id @default(uuid())
  connectionId String

  // Période synchronisée
  startDate DateTime
  endDate   DateTime

  // Résultats
  status                String @default("PENDING") // SUCCESS, PARTIAL, ERROR
  transactionsImported  Int    @default(0)
  transactionsProcessed Int    @default(0)
  transactionsFailed    Int    @default(0)

  // Erreurs
  errors Json? // Liste des erreurs rencontrées

  // Performance
  duration Int? // Durée en millisecondes

  // Métadonnées
  createdAt DateTime @default(now())

  @@map("sync_history")
}

// ========================================
// PRODUCT REVIEWS (Avis produits)
// ========================================

model Review {
  id String @id @default(uuid())

  // Product relation
  productId String
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  // Customer relation (optional - can be anonymous)
  customerId String?
  customer   Customer? @relation(fields: [customerId], references: [id], onDelete: SetNull)

  // Review content
  rating  Int // 1-5 stars
  title   String?
  comment String  @db.Text

  // Customer info for anonymous reviews
  customerName  String? // Si pas de customerId
  customerEmail String? // Si pas de customerId

  // Status
  isVerified  Boolean @default(false) // Achat vérifié
  isApproved  Boolean @default(false) // Modération
  isPublished Boolean @default(false) // Publié ou non

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([productId])
  @@index([isPublished])
  @@map("reviews")
}

// ========================================
// PERMISSIONS & RBAC
// ========================================

enum PermissionResource {
  DASHBOARD
  CUSTOMERS
  ORDERS
  QUOTES
  INVOICES
  PRODUCTS
  CATEGORIES
  SUPPLIERS
  PURCHASE_INVOICES
  STATISTICS
  ACCOUNTING
  PRICING
  GPS_TRACKING
  USERS
  SETTINGS
  IMPORT_EXPORT
  ACTIVITIES
  SHOP
  REVIEWS
}

enum PermissionAction {
  VIEW
  CREATE
  EDIT
  DELETE
  EXPORT
  IMPORT
}

model Permission {
  id          String             @id @default(uuid())
  name        String             @unique
  description String?
  resource    PermissionResource
  action      PermissionAction

  // Relations
  rolePermissions RolePermission[]
  userPermissions UserPermission[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([resource, action])
  @@map("permissions")
}

model RolePermission {
  id           String     @id @default(uuid())
  role         UserRole
  permissionId String
  permission   Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  // Override settings
  isGranted Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([role, permissionId])
  @@index([role])
  @@map("role_permissions")
}

model UserPermission {
  id           String     @id @default(uuid())
  userId       String
  user         User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  permissionId String
  permission   Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  // Override settings (can grant or revoke specific permission for a user)
  isGranted Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, permissionId])
  @@index([userId])
  @@map("user_permissions")
}
// ========================================
// SALES TRACKING - TRIP MANAGEMENT
// ========================================

enum TripStatus {
  IN_PROGRESS // Commercial en déplacement
  COMPLETED   // Trajet terminé
  CANCELLED   // Trajet annulé
}

enum VisitStatus {
  PLANNED    // Visite prévue
  IN_PROGRESS // En cours de visite
  COMPLETED  // Visite terminée
  CANCELLED  // Visite annulée
  NO_SHOW    // Client absent
}

enum TripPurpose {
  CLIENT_VISIT      // Visite client
  PROSPECTING       // Prospection
  DELIVERY          // Livraison
  AFTER_SALES       // SAV
  MEETING           // Réunion
  TRAINING          // Formation
  TRADE_SHOW        // Salon professionnel
  OTHER             // Autre
}

// Trajet commercial (du check-in au check-out)
model Trip {
  id String @id @default(uuid())

  // Commercial
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  status  TripStatus  @default(IN_PROGRESS)
  purpose TripPurpose @default(CLIENT_VISIT)

  // Horaires
  startTime DateTime  @default(now()) // Check-in
  endTime   DateTime? // Check-out

  // Positions GPS
  startLatitude  Float
  startLongitude Float
  startAddress   String?

  endLatitude  Float?
  endLongitude Float?
  endAddress   String?

  // Calculs kilométriques
  distanceKm       Float?   @default(0) // Distance parcourue
  estimatedKm      Float? // Distance estimée initiale
  mileageRate      Float?   @default(0.50) // Taux kilométrique (€/km)
  totalCost        Float?   @default(0) // Coût total (distance * taux)
  durationMinutes  Int?     @default(0) // Durée totale en minutes

  // Justificatifs
  vehicleType        String? // Type de véhicule (voiture, moto, etc.)
  vehicleRegistration String? // Immatriculation
  hasReceipts        Boolean @default(false) // A des justificatifs (parking, péage, etc.)
  receiptAmount      Float?  @default(0) // Montant total des justificatifs

  // Relations
  checkpoints TripCheckpoint[] // Points GPS le long du trajet
  visits      Visit[] // Visites clients pendant le trajet

  // Notes et objectifs
  objective String? // Objectif du déplacement
  notes     String? // Compte-rendu du trajet
  photos    String[] @default([]) // Photos du trajet (justificatifs, etc.)

  // Validation et remboursement
  isValidated       Boolean   @default(false)
  validatedAt       DateTime?
  validatedBy       String? // UserId de l'admin/manager
  isReimbursed      Boolean   @default(false)
  reimbursedAt      DateTime?
  reimbursementAmount Float? // Montant remboursé

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([status])
  @@index([startTime])
  @@map("trips")
}

// Points GPS enregistrés le long du trajet (pour traçabilité)
model TripCheckpoint {
  id String @id @default(uuid())

  tripId String
  trip   Trip   @relation(fields: [tripId], references: [id], onDelete: Cascade)

  // Position GPS
  latitude  Float
  longitude Float
  accuracy  Float? // Précision en mètres
  address   String?

  // Vitesse et cap (optionnel)
  speed   Float? // km/h
  heading Float? // Direction (0-360°)

  // Metadata
  timestamp DateTime @default(now())

  @@index([tripId])
  @@index([timestamp])
  @@map("trip_checkpoints")
}

// Visite client pendant un trajet
model Visit {
  id String @id @default(uuid())

  tripId String
  trip   Trip   @relation(fields: [tripId], references: [id], onDelete: Cascade)

  customerId String?
  customer   Customer? @relation(fields: [customerId], references: [id])

  status  VisitStatus  @default(PLANNED)
  purpose TripPurpose? @default(CLIENT_VISIT)

  // Horaires de visite
  scheduledAt DateTime? // Heure prévue
  checkInAt   DateTime? // Arrivée sur site
  checkOutAt  DateTime? // Départ du site
  duration    Int? // Durée en minutes

  // Position GPS de la visite
  latitude  Float?
  longitude Float?
  address   String?

  // Détails de la visite
  title        String? // Titre de la visite
  contactName  String? // Personne rencontrée
  contactPhone String? // Téléphone du contact
  contactEmail String? // Email du contact

  objective String? // Objectif de la visite
  summary   String? // Compte-rendu de la visite
  outcome   String? // Résultat (vente, devis, SAV, etc.)

  // Documents et photos
  photos     String[] @default([]) // Photos de la visite
  documents  String[] @default([]) // Documents remis/reçus
  signature  String? // Signature client (base64)

  // Commandes/Devis liés
  orderId String?
  quoteId String?

  // Satisfaction client
  satisfactionScore Int? // Note de 1 à 5

  // Follow-up
  nextVisitDate DateTime?
  followUpNotes String?

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([tripId])
  @@index([customerId])
  @@index([checkInAt])
  @@index([status])
  @@map("visits")
}

// ========================================
// DELIVERY & COURIER SYSTEM
// ========================================

// Statuts de livraison (workflow complet)
enum DeliveryStatus {
  CREATED      // Livraison créée
  OFFERED      // Offerte aux coursiers disponibles
  ACCEPTED     // Acceptée par un coursier
  TO_PICKUP    // En route vers le point de collecte
  AT_PICKUP    // Arrivé au point de collecte
  PICKED_UP    // Colis récupéré
  TO_DROPOFF   // En route vers le point de livraison
  AT_DROPOFF   // Arrivé au point de livraison
  DELIVERED    // Livré
  COMPLETED    // Terminé (après validation)
  CANCELED     // Annulé
  FAILED       // Échec de livraison
  INCIDENT     // Incident signalé
}

// Types d'événements de livraison (audit trail)
enum DeliveryEventType {
  STATUS_CHANGE    // Changement de statut
  LOCATION_UPDATE  // Mise à jour de position
  NOTE_ADDED       // Note ajoutée
  PHOTO_ADDED      // Photo ajoutée
  SIGNATURE_ADDED  // Signature ajoutée
  REASSIGNED       // Réassignation à un autre coursier
  INCIDENT         // Incident signalé
  CUSTOMER_CONTACT // Contact client
  ETA_UPDATE       // Mise à jour ETA
}

// Statut du profil coursier
enum CourierStatus {
  DRAFT       // Candidature en cours de remplissage
  SUBMITTED   // Candidature soumise
  UNDER_REVIEW // En cours de vérification
  APPROVED    // Approuvé (peut accepter des livraisons)
  REJECTED    // Rejeté
  SUSPENDED   // Suspendu temporairement
  BANNED      // Banni définitivement
}

// Types de véhicules
enum VehicleType {
  BIKE        // Vélo
  SCOOTER     // Scooter/Moto
  CAR         // Voiture
  VAN         // Camionnette
  TRUCK       // Camion
  ON_FOOT     // À pied
}

// Types de documents KYC
enum DocumentType {
  ID_CARD          // Carte d'identité
  DRIVERS_LICENSE  // Permis de conduire
  VEHICLE_REGISTRATION // Carte grise
  INSURANCE        // Assurance
  CRIMINAL_RECORD  // Casier judiciaire
  PROOF_ADDRESS    // Justificatif de domicile
  BANK_RIB         // RIB
  OTHER            // Autre
}

// Statut de validation des documents
enum DocumentStatus {
  PENDING     // En attente de vérification
  APPROVED    // Approuvé
  REJECTED    // Rejeté
  EXPIRED     // Expiré
}

// Types de notifications
enum NotificationType {
  DELIVERY_ASSIGNED    // Livraison assignée
  DELIVERY_OFFERED     // Livraison disponible
  STATUS_UPDATED       // Statut mis à jour
  COURIER_ARRIVED      // Coursier arrivé
  DELIVERY_COMPLETED   // Livraison terminée
  INCIDENT_REPORTED    // Incident signalé
  MESSAGE_RECEIVED     // Message reçu
  DOCUMENT_VERIFIED    // Document vérifié
  PROFILE_APPROVED     // Profil approuvé
  PROFILE_REJECTED     // Profil rejeté
  PAYOUT_READY         // Paiement disponible
  SYSTEM_ALERT         // Alerte système
}

// Statut de paiement coursier
enum PayoutStatus {
  PENDING      // En attente
  PROCESSING   // En cours de traitement
  COMPLETED    // Complété
  FAILED       // Échec
  CANCELED     // Annulé
}

// Livraison principale
model Delivery {
  id String @id @default(uuid())

  // Lien avec la commande (optionnel)
  orderId String?
  order   Order?   @relation(fields: [orderId], references: [id])

  // Client (destinataire)
  customerId String?
  customer   Customer? @relation(fields: [customerId], references: [id])

  // Commercial assigné (celui qui gère la vente)
  salesUserId String?
  salesUser   User?    @relation("DeliverySales", fields: [salesUserId], references: [id])

  // Coursier assigné
  courierId String?
  courier   User?    @relation("DeliveryCourier", fields: [courierId], references: [id])

  // Statut et workflow
  status            DeliveryStatus @default(CREATED)
  previousStatus    DeliveryStatus?
  statusChangedAt   DateTime       @default(now())
  canceledReason    String?
  failedReason      String?
  incidentDetails   String?

  // Adresses
  pickupAddress      String
  pickupLatitude     Float?
  pickupLongitude    Float?
  pickupContactName  String?
  pickupContactPhone String?
  pickupNotes        String?

  deliveryAddress      String
  deliveryLatitude     Float?
  deliveryLongitude    Float?
  deliveryContactName  String?
  deliveryContactPhone String?
  deliveryNotes        String?

  // Planning
  scheduledPickupAt  DateTime?
  scheduledDeliveryAt DateTime?
  estimatedDeliveryAt DateTime? // ETA calculé dynamiquement
  actualPickupAt     DateTime?
  actualDeliveryAt   DateTime?

  // Détails de la livraison
  packageDescription String?
  packageWeight      Float?  // en kg
  packageDimensions  String? // Format: "LxlxH cm"
  specialInstructions String?
  priority           Int     @default(0) // 0=normal, 1=urgent, 2=express

  // Preuves de livraison
  deliveryPhotos    String[] @default([]) // URLs ou Base64
  deliverySignature String? // Base64 de la signature
  recipientName     String? // Nom de la personne qui a reçu
  deliveryCode      String? // Code de vérification

  // Tarification
  deliveryFee       Float? // Frais de livraison
  courierEarnings   Float? // Gains du coursier
  currency          String @default("EUR")

  // Distance et durée (calculés)
  estimatedDistance Float? // en km
  actualDistance    Float? // en km
  estimatedDuration Int?   // en minutes
  actualDuration    Int?   // en minutes

  // Relations
  events         DeliveryEvent[]
  courierLocations CourierLocation[]
  notifications  Notification[]

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([orderId])
  @@index([customerId])
  @@index([salesUserId])
  @@index([courierId])
  @@index([status])
  @@index([scheduledDeliveryAt])
  @@index([createdAt])
  @@map("deliveries")
}

// Événements de livraison (audit trail immutable)
model DeliveryEvent {
  id String @id @default(uuid())

  deliveryId String
  delivery   Delivery @relation(fields: [deliveryId], references: [id], onDelete: Cascade)

  // Type et détails de l'événement
  type        DeliveryEventType
  description String?
  metadata    Json? // Données additionnelles flexibles

  // Statut (pour les changements de statut)
  oldStatus DeliveryStatus?
  newStatus DeliveryStatus?

  // Acteur de l'événement
  userId String?
  user   User?   @relation("DeliveryEventUser", fields: [userId], references: [id])
  actorRole UserRole? // Role de l'acteur au moment de l'événement

  // Géolocalisation (pour les événements liés à la position)
  latitude  Float?
  longitude Float?
  accuracy  Float?

  // Photos et documents
  photos String[] @default([])
  documents String[] @default([])

  // Timestamp (IMMUTABLE - append-only)
  timestamp DateTime @default(now())

  @@index([deliveryId])
  @@index([type])
  @@index([timestamp])
  @@map("delivery_events")
}

// Profil coursier (complément au User avec role=DELIVERY)
model CourierProfile {
  id String @id @default(uuid())

  userId String @unique
  user   User   @relation("CourierProfileUser", fields: [userId], references: [id], onDelete: Cascade)

  // Statut du coursier
  status         CourierStatus @default(DRAFT)
  statusNote     String? // Raison de rejet/suspension
  approvedAt     DateTime?
  approvedBy     String? // userId de l'admin qui a approuvé
  rejectedAt     DateTime?
  rejectedReason String?

  // Disponibilité
  isAvailable      Boolean @default(false)
  currentLatitude  Float?
  currentLongitude Float?
  lastLocationUpdate DateTime?

  // Informations personnelles complémentaires
  dateOfBirth   DateTime?
  nationality   String?
  address       String?
  city          String?
  postalCode    String?
  country       String    @default("France")

  // Informations véhicule
  vehicleType         VehicleType?
  vehicleBrand        String?
  vehicleModel        String?
  vehicleYear         Int?
  vehiclePlateNumber  String?
  vehicleColor        String?

  // Informations bancaires
  iban          String?
  bic           String?
  bankName      String?
  accountHolder String?

  // Préférences de travail
  maxDeliveriesPerDay Int? @default(10)
  maxRadius           Float? @default(20.0) // Rayon max en km
  workingDays         String[] @default([]) // ["Monday", "Tuesday", ...]
  workingHoursStart   String? // Format "09:00"
  workingHoursEnd     String? // Format "18:00"

  // Statistiques
  totalDeliveries      Int     @default(0)
  completedDeliveries  Int     @default(0)
  canceledDeliveries   Int     @default(0)
  failedDeliveries     Int     @default(0)
  averageRating        Float?
  totalEarnings        Float   @default(0.0)
  currentMonthEarnings Float   @default(0.0)

  // Scores de performance (calculés)
  onTimeRate       Float? // Pourcentage de livraisons à temps
  acceptanceRate   Float? // Pourcentage d'offres acceptées
  completionRate   Float? // Pourcentage de livraisons complétées
  customerSatisfaction Float? // Note moyenne clients

  // Documents KYC
  documents CourierDocument[]

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([status])
  @@index([isAvailable])
  @@map("courier_profiles")
}

// Documents du coursier (KYC)
model CourierDocument {
  id String @id @default(uuid())

  courierProfileId String
  courierProfile   CourierProfile @relation(fields: [courierProfileId], references: [id], onDelete: Cascade)

  // Type et statut du document
  type   DocumentType
  status DocumentStatus @default(PENDING)

  // Fichier
  fileUrl      String // URL ou Base64 du document
  fileName     String?
  fileSize     Int? // en bytes
  fileMimeType String?

  // Validation
  verifiedAt DateTime?
  verifiedBy String? // userId de l'admin qui a vérifié
  rejectedReason String?
  expiresAt  DateTime? // Date d'expiration (permis, assurance, etc.)

  // Notes admin
  adminNotes String?

  // Metadata
  uploadedAt DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([courierProfileId])
  @@index([type])
  @@index([status])
  @@index([expiresAt])
  @@map("courier_documents")
}

// Positions GPS du coursier (tracking en temps réel)
model CourierLocation {
  id String @id @default(uuid())

  // Coursier
  courierId String
  courier   User   @relation("CourierLocationUser", fields: [courierId], references: [id], onDelete: Cascade)

  // Livraison en cours (optionnel)
  deliveryId String?
  delivery   Delivery? @relation(fields: [deliveryId], references: [id], onDelete: Cascade)

  // Position GPS
  latitude  Float
  longitude Float
  accuracy  Float? // Précision en mètres
  altitude  Float?
  heading   Float? // Direction (0-360°)
  speed     Float? // Vitesse en km/h

  // Adresse (reverse geocoding)
  address String?

  // Metadata
  timestamp DateTime @default(now())

  @@index([courierId])
  @@index([deliveryId])
  @@index([timestamp])
  @@map("courier_locations")
}

// Notifications in-app
model Notification {
  id String @id @default(uuid())

  // Destinataire
  userId String
  user   User   @relation("NotificationUser", fields: [userId], references: [id], onDelete: Cascade)

  // Type et contenu
  type    NotificationType
  title   String
  message String
  data    Json? // Données additionnelles (deeplink, etc.)

  // Livraison liée (optionnel)
  deliveryId String?
  delivery   Delivery? @relation(fields: [deliveryId], references: [id], onDelete: Cascade)

  // État
  isRead  Boolean  @default(false)
  readAt  DateTime?
  isSent  Boolean  @default(false)
  sentAt  DateTime?

  // Priorité
  priority Int @default(0) // 0=normal, 1=high, 2=urgent

  // Metadata
  createdAt DateTime @default(now())
  expiresAt DateTime? // Expiration de la notification

  @@index([userId])
  @@index([deliveryId])
  @@index([type])
  @@index([isRead])
  @@index([createdAt])
  @@map("notifications")
}

// Paiements coursier (wallet/payout)
model Payout {
  id String @id @default(uuid())

  // Coursier
  courierId String
  courier   User   @relation("PayoutCourier", fields: [courierId], references: [id], onDelete: Cascade)

  // Montant
  amount        Float
  currency      String @default("EUR")
  taxAmount     Float? // Montant des taxes/commissions
  netAmount     Float  // Montant net reçu par le coursier

  // Période couverte
  periodStart DateTime
  periodEnd   DateTime

  // Statut
  status         PayoutStatus @default(PENDING)
  processedAt    DateTime?
  completedAt    DateTime?
  failedReason   String?
  transactionId  String? // ID de transaction externe (Stripe, etc.)

  // Détails bancaires (snapshot au moment du paiement)
  iban          String?
  bic           String?
  accountHolder String?

  // Livraisons incluses dans ce paiement
  deliveryIds String[] @default([]) // Liste des IDs de livraisons

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([courierId])
  @@index([status])
  @@index([periodStart])
  @@index([periodEnd])
  @@map("payouts")
}

// ========================================
// SHOP BANNERS (Bannières configurables pour le site e-commerce)
// ========================================

model ShopBanner {
  id String @id @default(uuid())

  // Type de bannière
  bannerType      String  @default("hero") // "hero", "flash_deals", "vacances", "offre_jour", "category_promo"

  // Configuration de base
  title           String? // Titre principal (ex: "Cyber Monday")
  subtitle        String? // Sous-titre (ex: "Fin de la promo : 31 décembre")
  description     String? // Description/texte additionnel
  ctaText         String? // Texte du bouton d'action (ex: "Voir les offres")
  ctaLink         String? // Lien du bouton

  // Style visuel
  backgroundType  String  @default("gradient") // "gradient", "image", "color"
  backgroundValue String? // Gradient CSS, URL d'image, ou couleur hex
  textColor       String  @default("#FFFFFF") // Couleur du texte
  buttonColor     String? // Couleur du bouton CTA

  // Images
  mainImage       String? // Image principale (ex: emoji cadeau, ou image upload)
  secondaryImages String[] @default([]) // Images secondaires

  // Mise en page
  layout          String  @default("horizontal") // "horizontal", "vertical", "centered"
  height          String  @default("medium") // "small", "medium", "large", "custom"
  customHeight    String? // Hauteur personnalisée (ex: "400px")

  // Positionnement des éléments (JSON pour flexibilité)
  positioning     Json? // {textAlign: "left", imagePosition: "right", etc.}

  // Badge de promotion
  showBadge       Boolean @default(false)
  badgeText       String? // Texte du badge (ex: "-70%")
  badgeColor      String? @default("#EF4444") // Rouge par défaut

  // Dates de validité
  startDate       DateTime?
  endDate         DateTime?
  showCountdown   Boolean @default(false) // Afficher un compte à rebours

  // Placement sur la page
  placement       String  @default("top") // "top", "after_categories", "middle_products", "before_footer"

  // État et priorité
  isActive        Boolean @default(true)
  priority        Int     @default(0) // Pour afficher plusieurs bannières (0 = plus haute priorité)

  // Metadata
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  createdBy       String? // UserId de l'admin qui a créé

  @@index([isActive])
  @@index([priority])
  @@index([placement])
  @@index([startDate])
  @@index([endDate])
  @@map("shop_banners")
}

// ========================================
// LOGISTICS SYSTEM - TASKS & INTERVENTIONS
// ========================================

enum TaskType {
  RECEPTION_INBOUND    // Réception marchandise en provenance de France
  DELIVERY_LAST_MILE   // Livraison locale
  SHIP_LAST_MILE       // Expédition locale (si external carrier)
}

enum TaskStatus {
  TODO         // À faire
  IN_PROGRESS  // En cours
  DONE         // Terminé (waiting validation)
  APPROVED     // Approuvé par SUB_ADMIN
  REJECTED     // Rejeté par SUB_ADMIN
  ISSUE        // Incident signalé
}

enum TaskProofType {
  PHOTO      // Photo de preuve
  SIGNATURE  // Signature électronique
  GPS        // Position GPS
  NOTE       // Note textuelle
  DOCUMENT   // Document attaché
}

enum TaskReviewStatus {
  APPROVED      // Validé
  REJECTED      // Rejeté
  PENDING_INFO  // En attente d'infos
}

// Task/Intervention principale
model Task {
  id String @id @default(uuid())

  // Lien avec la commande
  orderId String
  order   Order  @relation(fields: [orderId], references: [id], onDelete: Cascade)

  // Type et statut
  type   TaskType
  status TaskStatus @default(TODO)

  // Assignment
  assignedToId String?
  assignedTo   User?    @relation("TaskAssignedTo", fields: [assignedToId], references: [id], onDelete: SetNull)

  assignedById String?
  assignedBy   User?    @relation("TaskAssignedBy", fields: [assignedById], references: [id], onDelete: SetNull)

  assignedAt DateTime?

  // Scheduling
  scheduledAt DateTime?
  startedAt   DateTime?
  completedAt DateTime?

  // Details
  title       String
  description String?
  notes       String?

  // Location (if applicable)
  locationAddress   String?
  locationLatitude  Float?
  locationLongitude Float?

  // Relations
  proofs  TaskProof[]
  reviews TaskReview[]

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([orderId])
  @@index([assignedToId])
  @@index([status])
  @@index([type])
  @@index([scheduledAt])
  @@map("tasks")
}

// Preuves attachées à une tâche
model TaskProof {
  id String @id @default(uuid())

  taskId String
  task   Task   @relation(fields: [taskId], references: [id], onDelete: Cascade)

  // Type de preuve
  type TaskProofType

  // Contenu
  fileUrl       String? // Pour photos/documents
  signatureData String? @db.Text // Signature base64
  noteText      String? @db.Text

  // Données GPS
  latitude  Float?
  longitude Float?
  accuracy  Float?
  address   String?

  // Metadata
  uploadedById String?
  uploadedBy   User?    @relation("TaskProofUploadedBy", fields: [uploadedById], references: [id], onDelete: SetNull)

  uploadedAt DateTime @default(now())

  @@index([taskId])
  @@index([type])
  @@map("task_proofs")
}

// Reviews/Validations par SUB_ADMIN
model TaskReview {
  id String @id @default(uuid())

  taskId String
  task   Task   @relation(fields: [taskId], references: [id], onDelete: Cascade)

  // Review details
  status   TaskReviewStatus
  comments String?          @db.Text

  // Actions prises (JSON: reassigned, reopened, etc.)
  actionsTaken Json?

  // Reviewer
  reviewedById String
  reviewedBy   User   @relation("TaskReviewedBy", fields: [reviewedById], references: [id], onDelete: Cascade)

  reviewedAt DateTime @default(now())

  @@index([taskId])
  @@index([reviewedById])
  @@index([status])
  @@map("task_reviews")
}
