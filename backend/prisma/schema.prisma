generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ========================================
// USERS & AUTHENTICATION
// ========================================

enum UserRole {
  ADMIN
  COMMERCIAL
  DELIVERY
  CLIENT
  ACCOUNTANT
}

enum UserStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
}

model User {
  id          String     @id @default(uuid())
  email       String     @unique
  password    String
  firstName   String?
  lastName    String?
  phone       String?
  avatar      String?
  role        UserRole   @default(CLIENT)
  status      UserStatus @default(ACTIVE)
  permissions Json? // Section-level permissions: {"dashboard": true, "customers": false, ...}

  // Horaires de travail (informatifs)
  workStartTime String? // Format "09:00"
  workEndTime   String? // Format "18:00"
  workDays      String[] @default([]) // ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"]
  timezone      String?  @default("Europe/Paris")

  // Tracking de connexion
  isOnline         Boolean   @default(false)
  lastSeenAt       DateTime?
  currentSessionId String?

  // Relations
  customers       Customer[]       @relation("UserCustomers")
  orders          Order[]
  quotes          Quote[]
  invoices        Invoice[]
  gpsTrackings    GpsTracking[]
  activities      Activity[]
  importHistory   ImportHistory[]
  userPermissions UserPermission[]
  connectionLogs  ConnectionLog[]
  creditNotes     CreditNote[]
  bankConnections BankConnection[] // Synchronisation bancaire
  trips           Trip[] // Trajets commerciaux

  // Metadata
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  lastLoginAt DateTime?

  @@map("users")
}

// Historique des connexions
model ConnectionLog {
  id        String    @id @default(uuid())
  userId    String
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  sessionId String    @unique
  loginAt   DateTime  @default(now())
  logoutAt  DateTime?
  ipAddress String?
  userAgent String?
  duration  Int? // Durée en secondes

  @@index([userId])
  @@index([loginAt])
  @@map("connection_logs")
}

// ========================================
// CRM - CUSTOMERS
// ========================================

enum CustomerType {
  INDIVIDUAL
  COMPANY
}

enum CustomerStatus {
  PROSPECT
  ACTIVE
  INACTIVE
  BLOCKED
}

model Customer {
  id     String         @id @default(uuid())
  type   CustomerType   @default(INDIVIDUAL)
  status CustomerStatus @default(PROSPECT)

  // Individual fields
  firstName String?
  lastName  String?

  // Company fields
  companyName String?
  siret       String?
  vatNumber   String?

  // Authentication
  password String? // Mot de passe hashé (nullable pour compatibilité avec clients existants)

  // Contact
  email    String  @unique
  phone    String?
  mobile   String?
  phone2   String? // Téléphone secondaire
  fax      String?
  whatsapp String?

  // Address
  address      String?
  addressLine2 String?
  city         String?
  postalCode   String?
  country      String? @default("France")
  latitude     Float? // Latitude GPS pour affichage sur carte
  longitude    Float? // Longitude GPS pour affichage sur carte

  // Commercial
  userId String
  user   User   @relation("UserCustomers", fields: [userId], references: [id], onDelete: Cascade)

  // Relations
  orders            Order[]
  quotes            Quote[]
  invoices          Invoice[]
  activities        Activity[]
  reviews           Review[]
  accountingEntries AccountingEntry[]
  visits            Visit[] // Visites commerciales

  // Notes & Tags
  notes String?
  tags  String[]

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("customers")
}

// ========================================
// SUPPLIERS (Fournisseurs)
// ========================================

enum SupplierStatus {
  ACTIVE
  INACTIVE
  BLOCKED
}

model Supplier {
  id String @id @default(uuid())

  // Company Info
  companyName   String
  contactPerson String?
  siret         String?
  vatNumber     String?

  // Contact
  email   String  @unique
  phone   String?
  mobile  String?
  website String?

  // Address
  address      String?
  addressLine2 String?
  city         String?
  postalCode   String?
  country      String? @default("France")

  // Status
  status SupplierStatus @default(ACTIVE)

  // Payment Terms
  paymentTerms  String? // e.g., "30 jours fin de mois"
  paymentMethod String? // e.g., "Virement", "Chèque"

  // Relations
  products          Product[]
  purchaseInvoices  PurchaseInvoice[]
  accountingEntries AccountingEntry[]

  // Notes
  notes String?
  tags  String[]

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("suppliers")
}

// ========================================
// PRODUCTS & INVENTORY
// ========================================

enum ProductStatus {
  ACTIVE
  INACTIVE
  OUT_OF_STOCK
}

enum AvailabilityStatus {
  AVAILABLE // Disponible (vert)
  UNAVAILABLE // Non disponible (rouge)
  INCOMING // En cours d'arrivage (jaune)
}

model Category {
  id          String     @id @default(uuid())
  name        String
  slug        String     @unique
  description String?
  image       String?
  isVisible   Boolean    @default(true)
  parentId    String?
  parent      Category?  @relation("CategoryHierarchy", fields: [parentId], references: [id])
  children    Category[] @relation("CategoryHierarchy")
  products    Product[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("categories")
}

model Product {
  id               String  @id @default(uuid())
  sku              String  @unique
  barcode          String? @unique
  name             String
  slug             String  @unique
  description      String?
  shortDescription String?

  // Pricing
  price          Float
  costPrice      Float?
  compareAtPrice Float?

  // Stock
  stock    Int  @default(0)
  minStock Int? @default(5)
  maxStock Int?

  // Status
  status             ProductStatus      @default(ACTIVE)
  availabilityStatus AvailabilityStatus @default(AVAILABLE)
  isVisible          Boolean            @default(true)
  isFeatured         Boolean            @default(false)

  // Media
  images    String[]
  thumbnail String?

  // Category (OBLIGATOIRE - un produit doit toujours avoir une catégorie)
  categoryId String
  category   Category @relation(fields: [categoryId], references: [id])

  // Supplier
  supplierId String?
  supplier   Supplier? @relation(fields: [supplierId], references: [id])

  // Dimensions & Shipping
  weight Float?
  width  Float?
  height Float?
  length Float?

  // Relations
  orderItems           OrderItem[]
  quoteItems           QuoteItem[]
  invoiceItems         InvoiceItem[]
  creditNoteItems      CreditNoteItem[]
  purchaseInvoiceItems PurchaseInvoiceItem[]
  stockMovements       StockMovement[]
  reviews              Review[]

  // SEO
  metaTitle       String?
  metaDescription String?
  metaKeywords    String[]

  // Tags
  tags String[]

  // Champ lexical pour recherche intelligente
  searchTerms String[] @default([])

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("products")
}

// ========================================
// QUOTES (Devis)
// ========================================

enum QuoteStatus {
  DRAFT
  SENT
  ACCEPTED
  REJECTED
  EXPIRED
}

model Quote {
  id     String @id @default(uuid())
  number String @unique

  // Customer
  customerId String
  customer   Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)

  // Commercial
  userId String
  user   User   @relation(fields: [userId], references: [id])

  // Status
  status QuoteStatus @default(DRAFT)

  // Items
  items QuoteItem[]

  // Amounts
  subtotal  Float @default(0)
  taxAmount Float @default(0)
  discount  Float @default(0)
  total     Float @default(0)

  // Dates
  validUntil DateTime?
  sentAt     DateTime?
  acceptedAt DateTime?

  // Notes
  notes           String?
  termsConditions String?

  // PDF
  pdfUrl String?

  // GPS Location when created
  gpsLatitude  Float?
  gpsLongitude Float?
  gpsAddress   String?

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("quotes")
}

model QuoteItem {
  id      String @id @default(uuid())
  quoteId String
  quote   Quote  @relation(fields: [quoteId], references: [id], onDelete: Cascade)

  productId String
  product   Product @relation(fields: [productId], references: [id])

  quantity  Int
  unitPrice Float
  taxRate   Float @default(20)
  discount  Float @default(0)
  total     Float

  createdAt DateTime @default(now())

  @@map("quote_items")
}

// ========================================
// ORDERS (Commandes)
// ========================================

enum OrderStatus {
  PENDING
  CONFIRMED
  PROCESSING
  SHIPPED
  DELIVERED
  CANCELLED
}

enum PaymentStatus {
  PENDING
  PAID
  PARTIAL
  REFUNDED
  FAILED
}

model Order {
  id     String @id @default(uuid())
  number String @unique

  // Customer
  customerId String
  customer   Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)

  // Commercial
  userId String
  user   User   @relation(fields: [userId], references: [id])

  // Status
  status        OrderStatus   @default(PENDING)
  paymentStatus PaymentStatus @default(PENDING)

  // Items
  items OrderItem[]

  // Amounts
  subtotal     Float @default(0)
  taxAmount    Float @default(0)
  shippingCost Float @default(0)
  discount     Float @default(0)
  total        Float @default(0)

  // Shipping Address
  shippingAddress    String?
  shippingCity       String?
  shippingPostalCode String?
  shippingCountry    String?

  // Notes
  notes        String?
  customerNote String?

  // Payments
  payments Payment[]

  // Invoice
  invoice Invoice?

  // PDF Documents
  orderPdfUrl        String?
  deliveryNotePdfUrl String?

  // GPS Location
  gpsLatitude  Float?
  gpsLongitude Float?
  gpsAddress   String?

  // Dates
  confirmedAt DateTime?
  shippedAt   DateTime?
  deliveredAt DateTime?

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("orders")
}

model OrderItem {
  id      String @id @default(uuid())
  orderId String
  order   Order  @relation(fields: [orderId], references: [id], onDelete: Cascade)

  productId String
  product   Product @relation(fields: [productId], references: [id])

  quantity  Int
  unitPrice Float
  taxRate   Float @default(20)
  discount  Float @default(0)
  total     Float

  createdAt DateTime @default(now())

  @@map("order_items")
}

// ========================================
// INVOICES (Factures)
// ========================================

enum InvoiceStatus {
  DRAFT
  SENT
  PAID
  OVERDUE
  CANCELLED
}

model Invoice {
  id     String @id @default(uuid())
  number String @unique

  // Customer
  customerId String
  customer   Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)

  // Commercial
  userId String
  user   User   @relation(fields: [userId], references: [id])

  // Order
  orderId String? @unique
  order   Order?  @relation(fields: [orderId], references: [id])

  // Status
  status InvoiceStatus @default(DRAFT)

  // Items
  items InvoiceItem[]

  // Amounts
  subtotal   Float @default(0)
  tax        Float @default(0)
  taxAmount  Float @default(0)
  discount   Float @default(0)
  total      Float @default(0)
  paidAmount Float @default(0)

  // Accounting
  accountingEntryId String?          @unique
  accountingEntry   AccountingEntry? @relation(fields: [accountingEntryId], references: [id])

  // Dates
  issueDate DateTime  @default(now())
  dueDate   DateTime?
  paidAt    DateTime?

  // Notes
  notes           String?
  termsConditions String?

  // PDF
  pdfUrl String?

  // Payments
  payments Payment[]

  // Credit Notes (Avoirs)
  creditNotes CreditNote[]

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("invoices")
}

model InvoiceItem {
  id        String  @id @default(uuid())
  invoiceId String
  invoice   Invoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  productId String
  product   Product @relation(fields: [productId], references: [id])

  quantity  Int
  unitPrice Float
  taxRate   Float @default(20)
  discount  Float @default(0)
  total     Float

  createdAt DateTime @default(now())

  @@map("invoice_items")
}

// ========================================
// CREDIT NOTES (AVOIRS)
// ========================================

enum CreditNoteType {
  TOTAL    // Avoir total (annule toute la facture)
  PARTIAL  // Avoir partiel (annule certains produits)
}

model CreditNote {
  id        String          @id @default(uuid())
  number    String          @unique // Ex: AV-2024-001
  type      CreditNoteType  @default(TOTAL)
  reason    String?         // Motif de l'avoir

  // Relation avec la facture d'origine
  invoiceId String
  invoice   Invoice         @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  // Commercial qui a créé l'avoir
  userId    String
  user      User            @relation(fields: [userId], references: [id])

  // Items concernés par l'avoir
  items     CreditNoteItem[]

  // Montants
  subtotal   Float          @default(0)
  taxAmount  Float          @default(0)
  total      Float          @default(0)

  // Notes
  notes      String?

  // PDF
  pdfUrl     String?

  // Metadata
  createdAt  DateTime       @default(now())
  updatedAt  DateTime       @updatedAt

  @@map("credit_notes")
}

model CreditNoteItem {
  id            String      @id @default(uuid())
  creditNoteId  String
  creditNote    CreditNote  @relation(fields: [creditNoteId], references: [id], onDelete: Cascade)

  productId     String
  product       Product     @relation(fields: [productId], references: [id])

  quantity      Int
  unitPrice     Float
  taxRate       Float       @default(20)
  discount      Float       @default(0)
  total         Float

  createdAt     DateTime    @default(now())

  @@map("credit_note_items")
}

// ========================================
// PAYMENTS
// ========================================

enum PaymentMethod {
  CREDIT_CARD
  STRIPE
  PAYPAL
  PAYLIB
  BANK_TRANSFER
  CASH
  CHECK
}

enum PaymentStatusEnum {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
  CANCELLED
}

model Payment {
  id String @id @default(uuid())

  // Order or Invoice
  orderId String?
  order   Order?  @relation(fields: [orderId], references: [id])

  invoiceId String?
  invoice   Invoice? @relation(fields: [invoiceId], references: [id])

  // Payment details
  amount Float
  method PaymentMethod
  status PaymentStatusEnum @default(PENDING)

  // External references
  transactionId   String?
  stripePaymentId String?
  paypalOrderId   String?

  // Metadata
  metadata Json?
  notes    String?

  // Dates
  paidAt     DateTime?
  refundedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("payments")
}

// ========================================
// GPS TRACKING
// ========================================

enum ActionType {
  CUSTOMER_VISIT
  QUOTE_CREATED
  ORDER_CREATED
  DELIVERY
  MEETING
  PHONE_CALL
  OTHER
}

model GpsTracking {
  id String @id @default(uuid())

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  actionType ActionType

  // GPS Coordinates
  latitude  Float
  longitude Float
  accuracy  Float?
  address   String?

  // Related entities
  customerId String?
  orderId    String?
  quoteId    String?

  // Notes
  notes String?

  // Metadata
  timestamp DateTime @default(now())
  createdAt DateTime @default(now())

  @@map("gps_trackings")
}

// ========================================
// ACTIVITY LOG
// ========================================

enum ActivityType {
  CUSTOMER_CREATED
  CUSTOMER_UPDATED
  QUOTE_CREATED
  QUOTE_SENT
  QUOTE_ACCEPTED
  ORDER_CREATED
  ORDER_CONFIRMED
  ORDER_SHIPPED
  ORDER_DELIVERED
  INVOICE_CREATED
  INVOICE_SENT
  INVOICE_PAID
  PAYMENT_RECEIVED
  PRODUCT_CREATED
  PRODUCT_UPDATED
  USER_LOGIN
  OTHER
}

model Activity {
  id String @id @default(uuid())

  type        ActivityType
  description String

  userId String?
  user   User?   @relation(fields: [userId], references: [id])

  customerId String?
  customer   Customer? @relation(fields: [customerId], references: [id])

  metadata Json?

  createdAt DateTime @default(now())

  @@map("activities")
}

// ========================================
// MASS IMPORT
// ========================================

enum ImportStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

enum ImportType {
  PRODUCTS
  CUSTOMERS
  ORDERS
}

model Import {
  id String @id @default(uuid())

  type   ImportType
  status ImportStatus @default(PENDING)

  fileName String
  filePath String

  totalRows     Int @default(0)
  processedRows Int @default(0)
  successRows   Int @default(0)
  failedRows    Int @default(0)

  errors Json?

  startedAt   DateTime?
  completedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("imports")
}

// ========================================
// SETTINGS
// ========================================

model Settings {
  id    String @id @default(uuid())
  key   String @unique
  value String
  type  String @default("string")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("settings")
}

// ========================================
// PURCHASE INVOICES (Factures d'achat)
// ========================================

enum PurchaseInvoiceStatus {
  DRAFT
  VALIDATED
  PAID
  CANCELLED
}

model PurchaseInvoice {
  id     String @id @default(uuid())
  number String @unique

  // Supplier
  supplierId String
  supplier   Supplier @relation(fields: [supplierId], references: [id])

  // Status
  status PurchaseInvoiceStatus @default(DRAFT)

  // Items
  items PurchaseInvoiceItem[]

  // Amounts
  subtotal  Float @default(0)
  tax       Float @default(0)
  taxAmount Float @default(0)
  discount  Float @default(0)
  total     Float @default(0)

  // Dates
  date        DateTime  @default(now())
  invoiceDate DateTime  @default(now())
  dueDate     DateTime?
  paidAt      DateTime?

  // Notes
  notes     String?
  reference String? // Numéro de facture fournisseur

  // PDF
  pdfUrl String?

  // Accounting
  accountingEntryId String?          @unique
  accountingEntry   AccountingEntry? @relation(fields: [accountingEntryId], references: [id])

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("purchase_invoices")
}

model PurchaseInvoiceItem {
  id                String          @id @default(uuid())
  purchaseInvoiceId String
  purchaseInvoice   PurchaseInvoice @relation(fields: [purchaseInvoiceId], references: [id], onDelete: Cascade)

  productId String
  product   Product @relation(fields: [productId], references: [id])

  quantity  Int
  unitPrice Float
  taxRate   Float @default(20)
  discount  Float @default(0)
  total     Float

  createdAt DateTime @default(now())

  @@map("purchase_invoice_items")
}

// ========================================
// STOCK MOVEMENTS (Mouvements de stock)
// ========================================

enum StockMovementType {
  PURCHASE // Achat fournisseur
  SALE // Vente client
  RETURN // Retour
  ADJUSTMENT // Ajustement manuel
  TRANSFER // Transfert
  LOSS // Perte/casse
}

model StockMovement {
  id String @id @default(uuid())

  productId String
  product   Product @relation(fields: [productId], references: [id])

  type        StockMovementType
  quantity    Int // Positif = entrée, Négatif = sortie
  stockBefore Int // Stock avant mouvement
  stockAfter  Int // Stock après mouvement

  // References
  orderId           String?
  purchaseInvoiceId String?
  referenceNumber   String? // Numéro de référence (bon de livraison, etc.)

  // User who made the movement
  userId String?
  notes  String?

  movementDate DateTime @default(now())
  createdAt    DateTime @default(now())

  @@map("stock_movements")
}

// ========================================
// ACCOUNTING (Comptabilité)
// ========================================

enum AccountType {
  ASSET // Classe 1-2 (Actif)
  LIABILITY // Classe 1 (Passif)
  EQUITY // Classe 1 (Capitaux propres)
  REVENUE // Classe 7 (Produits)
  EXPENSE // Classe 6 (Charges)
}

enum JournalType {
  VENTE // Journal des ventes
  ACHAT // Journal des achats
  BANQUE // Journal de banque
  CAISSE // Journal de caisse
  OD // Opérations diverses
}

model AccountingAccount {
  id   String      @id @default(uuid())
  code String      @unique // ex: "401000", "707000"
  name String // ex: "Fournisseurs", "Ventes de marchandises"
  type AccountType

  // Hierarchy
  parentId String?
  parent   AccountingAccount?  @relation("AccountHierarchy", fields: [parentId], references: [id])
  children AccountingAccount[] @relation("AccountHierarchy")

  // Relations
  entryLines   AccountingEntryLine[]
  bankAccounts BankAccount[] // Comptes bancaires mappés à ce compte comptable

  // Metadata
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("accounting_accounts")
}

enum AccountingEntryStatus {
  DRAFT
  VALIDATED
}

model AccountingEntry {
  id      String                @id @default(uuid())
  number  String                @unique
  date    DateTime              @default(now())
  label   String
  journal JournalType
  status  AccountingEntryStatus @default(DRAFT)

  // Relations
  lines AccountingEntryLine[]

  // Source documents
  invoiceId       String?          @unique
  invoice         Invoice?
  purchaseInvoice PurchaseInvoice?

  orderId   String?
  reference String? // Numéro de pièce

  // FEC - Champs obligatoires pour le fichier FEC
  journalCode    String  // VE, AC, BQ, CA, OD, AN (code du journal)
  journalLabel   String  // "Ventes", "Achats", "Banque", etc.
  pieceRef       String? // Référence de la pièce justificative
  pieceDate      DateTime? // Date de la pièce
  validationDate DateTime? // Date de validation de l'écriture

  // FEC - Lettrage (pour rapprochements)
  lettrage     String? // Code de lettrage (ex: "A", "B", "C")
  lettrageDate DateTime? // Date du lettrage

  // FEC - Tiers (client ou fournisseur)
  thirdPartyCode  String? // Code auxiliaire (ex: "C0001", "F0001")
  thirdPartyLabel String? // Nom du tiers
  customerId      String?
  customer        Customer? @relation(fields: [customerId], references: [id])
  supplierId      String?
  supplier        Supplier? @relation(fields: [supplierId], references: [id])

  // Synchronisation bancaire
  bankTransaction BankTransaction? // Lien vers transaction bancaire (si automatique)

  // Metadata
  notes     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("accounting_entries")
}

model AccountingEntryLine {
  id String @id @default(uuid())

  entryId String
  entry   AccountingEntry @relation(fields: [entryId], references: [id], onDelete: Cascade)

  accountId String
  account   AccountingAccount @relation(fields: [accountId], references: [id])

  label  String?
  debit  Float   @default(0)
  credit Float   @default(0)

  // FEC - Devise (pour opérations en devises étrangères)
  amountCurrency Float?  // Montant en devise étrangère
  currency       String? // Code devise ISO (EUR, USD, GBP, etc.)

  createdAt DateTime @default(now())

  @@map("accounting_entry_lines")
}

// ========================================
// IMPORT HISTORY
// ========================================

model ImportHistory {
  id           String @id @default(uuid())
  type         String // CUSTOMERS, PRODUCTS, SUPPLIERS, STOCKS
  totalRows    Int
  successCount Int    @default(0)
  errorCount   Int    @default(0)
  warningCount Int    @default(0)

  userId String
  user   User   @relation(fields: [userId], references: [id])

  errors   String? @db.Text // JSON string
  warnings String? @db.Text // JSON string

  createdAt DateTime @default(now())

  @@map("import_history")
}

// ========================================
// FEC EXPORT HISTORY
// ========================================

model FECExport {
  id       String @id @default(uuid())
  filename String // fec_SIREN_YYYYMMDD_HHMMSS.txt
  siren    String // 9 chiffres

  // Période couverte
  startDate DateTime // Date début période
  endDate   DateTime // Date fin période

  // Format du fichier
  format String @default("txt") // txt ou csv

  // Chemin du fichier généré
  filePath String?

  // Statut de l'export
  status String @default("PENDING") // PENDING, COMPLETED, ERROR

  // Statistiques
  totalEntries Int?   // Nombre d'écritures exportées
  totalLines   Int?   // Nombre de lignes d'écriture
  totalDebit   Float? // Total des débits
  totalCredit  Float? // Total des crédits

  // Métadonnées
  createdBy String?
  createdAt DateTime @default(now())

  @@map("fec_exports")
}

// ========================================
// BANK SYNCHRONIZATION (Synchronisation bancaire style Pennylane)
// ========================================

// Connexion bancaire (Bridge API, Budget Insight, etc.)
model BankConnection {
  id String @id @default(uuid())

  // Utilisateur propriétaire
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Informations banque
  bankName String // "BNP Paribas", "Crédit Agricole", etc.
  bankLogo String? // URL du logo

  // Authentification API
  provider     String // "bridge", "budget_insight", "plaid"
  accessToken  String @db.Text // Token d'accès (chiffré)
  refreshToken String? @db.Text // Token de rafraîchissement
  expiresAt    DateTime?

  // Statut
  status   String    @default("ACTIVE") // ACTIVE, ERROR, DISCONNECTED
  lastSync DateTime?
  nextSync DateTime?

  // Métadonnées
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  accounts BankAccount[]

  @@map("bank_connections")
}

// Compte bancaire
model BankAccount {
  id           String         @id @default(uuid())
  connectionId String
  connection   BankConnection @relation(fields: [connectionId], references: [id], onDelete: Cascade)

  // Informations compte
  accountNumber String // Numéro de compte (masqué: ****1234)
  iban          String? // IBAN complet (chiffré)
  accountName   String // "Compte courant", "Compte épargne"
  accountType   String // "checking", "savings", "credit_card"
  currency      String  @default("EUR")

  // Soldes
  balance     Float // Solde actuel
  balanceDate DateTime // Date du solde

  // Mapping comptable
  accountingAccountId String?
  accountingAccount   AccountingAccount? @relation(fields: [accountingAccountId], references: [id])

  // Statut
  status String @default("ACTIVE")

  // Métadonnées
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  transactions BankTransaction[]

  @@map("bank_accounts")
}

// Transaction bancaire brute
model BankTransaction {
  id            String      @id @default(uuid())
  bankAccountId String
  bankAccount   BankAccount @relation(fields: [bankAccountId], references: [id], onDelete: Cascade)

  // Identifiant unique de la banque
  externalId String // ID fourni par l'API bancaire

  // Informations transaction
  date      DateTime // Date de la transaction
  valueDate DateTime? // Date de valeur
  amount    Float // Montant (négatif = débit, positif = crédit)
  currency  String   @default("EUR")

  // Description
  rawLabel   String  @db.Text // Libellé brut de la banque
  cleanLabel String? @db.Text // Libellé nettoyé (sans codes techniques)
  category   String? // Catégorie détectée par l'IA

  // Contrepartie
  counterparty     String? // Nom du tiers (bénéficiaire/émetteur)
  counterpartyIBAN String? // IBAN de la contrepartie

  // Statut de traitement
  status String @default("PENDING") // PENDING, PROCESSED, IGNORED, ERROR

  // Catégorisation IA
  aiCategoryConfidence Float? // Confiance de l'IA (0-1)
  aiSuggestedAccount   String? // Compte comptable suggéré
  aiSuggestedVAT       Float? // TVA suggérée (20%, 10%, 5.5%, etc.)
  aiReasoning          String? @db.Text // Explication de l'IA

  // Mapping comptable
  accountingEntryId String?          @unique
  accountingEntry   AccountingEntry? @relation(fields: [accountingEntryId], references: [id])

  // Règle appliquée (si automatique)
  ruleId String?
  rule   TransactionRule? @relation(fields: [ruleId], references: [id])

  // Métadonnées
  processedAt DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  // Relations
  reconciliationMatches ReconciliationMatch[]

  @@unique([bankAccountId, externalId])
  @@index([date])
  @@index([status])
  @@map("bank_transactions")
}

// Règles de catégorisation automatique
model TransactionRule {
  id     String @id @default(uuid())
  userId String // Utilisateur propriétaire

  // Conditions de déclenchement
  name        String // Nom de la règle
  description String?
  priority    Int     @default(0) // Ordre d'application (0 = haute priorité)

  // Critères de matching
  matchType  String // "contains", "starts_with", "ends_with", "exact", "regex"
  matchValue String // Valeur à chercher dans le libellé
  matchField String @default("rawLabel") // rawLabel, counterparty, amount

  // Conditions supplémentaires
  minAmount     Float? // Montant minimum
  maxAmount     Float? // Montant maximum
  amountType    String? // "debit", "credit", "both"
  bankAccountId String? // Compte bancaire spécifique

  // Actions à appliquer
  category              String // Catégorie à appliquer
  accountingAccountCode String // Code du compte comptable
  vatRate               Float? // Taux de TVA à appliquer
  journalCode           String // Code journal (VE, AC, BQ, etc.)

  // Tiers
  customerCode String? // Code client automatique
  supplierCode String? // Code fournisseur automatique

  // Auto-validation
  autoValidate Boolean @default(false) // Valider automatiquement l'écriture

  // Statut
  isActive Boolean @default(true)

  // Statistiques
  timesApplied  Int       @default(0)
  lastAppliedAt DateTime?

  // Métadonnées
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  transactions BankTransaction[]

  @@map("transaction_rules")
}

// Rapprochement (matching facture ↔ paiement)
model ReconciliationMatch {
  id            String          @id @default(uuid())
  transactionId String
  transaction   BankTransaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)

  // Document lié (facture, avoir, etc.)
  documentType String // "invoice", "credit_note", "quote", "expense"
  documentId   String // ID du document

  // Montant du rapprochement
  matchedAmount Float // Montant rapproché (peut être partiel)

  // Statut
  status     String @default("MATCHED") // MATCHED, PARTIAL, UNMATCHED
  confidence Float // Confiance du matching (0-1)

  // IA
  isAutomatic Boolean @default(false) // Matching automatique ou manuel
  aiReasoning String? @db.Text // Explication de l'IA

  // Validation
  validatedBy String? // ID utilisateur qui a validé
  validatedAt DateTime?

  // Métadonnées
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("reconciliation_matches")
}

// Historique de synchronisation
model SyncHistory {
  id           String @id @default(uuid())
  connectionId String

  // Période synchronisée
  startDate DateTime
  endDate   DateTime

  // Résultats
  status                String @default("PENDING") // SUCCESS, PARTIAL, ERROR
  transactionsImported  Int    @default(0)
  transactionsProcessed Int    @default(0)
  transactionsFailed    Int    @default(0)

  // Erreurs
  errors Json? // Liste des erreurs rencontrées

  // Performance
  duration Int? // Durée en millisecondes

  // Métadonnées
  createdAt DateTime @default(now())

  @@map("sync_history")
}

// ========================================
// PRODUCT REVIEWS (Avis produits)
// ========================================

model Review {
  id String @id @default(uuid())

  // Product relation
  productId String
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  // Customer relation (optional - can be anonymous)
  customerId String?
  customer   Customer? @relation(fields: [customerId], references: [id], onDelete: SetNull)

  // Review content
  rating  Int // 1-5 stars
  title   String?
  comment String  @db.Text

  // Customer info for anonymous reviews
  customerName  String? // Si pas de customerId
  customerEmail String? // Si pas de customerId

  // Status
  isVerified  Boolean @default(false) // Achat vérifié
  isApproved  Boolean @default(false) // Modération
  isPublished Boolean @default(false) // Publié ou non

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([productId])
  @@index([isPublished])
  @@map("reviews")
}

// ========================================
// PERMISSIONS & RBAC
// ========================================

enum PermissionResource {
  DASHBOARD
  CUSTOMERS
  ORDERS
  QUOTES
  INVOICES
  PRODUCTS
  CATEGORIES
  SUPPLIERS
  PURCHASE_INVOICES
  STATISTICS
  ACCOUNTING
  PRICING
  GPS_TRACKING
  USERS
  SETTINGS
  IMPORT_EXPORT
  ACTIVITIES
  SHOP
  REVIEWS
}

enum PermissionAction {
  VIEW
  CREATE
  EDIT
  DELETE
  EXPORT
  IMPORT
}

model Permission {
  id          String             @id @default(uuid())
  name        String             @unique
  description String?
  resource    PermissionResource
  action      PermissionAction

  // Relations
  rolePermissions RolePermission[]
  userPermissions UserPermission[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([resource, action])
  @@map("permissions")
}

model RolePermission {
  id           String     @id @default(uuid())
  role         UserRole
  permissionId String
  permission   Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  // Override settings
  isGranted Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([role, permissionId])
  @@index([role])
  @@map("role_permissions")
}

model UserPermission {
  id           String     @id @default(uuid())
  userId       String
  user         User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  permissionId String
  permission   Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  // Override settings (can grant or revoke specific permission for a user)
  isGranted Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, permissionId])
  @@index([userId])
  @@map("user_permissions")
}
// ========================================
// SALES TRACKING - TRIP MANAGEMENT
// ========================================

enum TripStatus {
  IN_PROGRESS // Commercial en déplacement
  COMPLETED   // Trajet terminé
  CANCELLED   // Trajet annulé
}

enum VisitStatus {
  PLANNED    // Visite prévue
  IN_PROGRESS // En cours de visite
  COMPLETED  // Visite terminée
  CANCELLED  // Visite annulée
  NO_SHOW    // Client absent
}

enum TripPurpose {
  CLIENT_VISIT      // Visite client
  PROSPECTING       // Prospection
  DELIVERY          // Livraison
  AFTER_SALES       // SAV
  MEETING           // Réunion
  TRAINING          // Formation
  TRADE_SHOW        // Salon professionnel
  OTHER             // Autre
}

// Trajet commercial (du check-in au check-out)
model Trip {
  id String @id @default(uuid())

  // Commercial
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  status  TripStatus  @default(IN_PROGRESS)
  purpose TripPurpose @default(CLIENT_VISIT)

  // Horaires
  startTime DateTime  @default(now()) // Check-in
  endTime   DateTime? // Check-out

  // Positions GPS
  startLatitude  Float
  startLongitude Float
  startAddress   String?

  endLatitude  Float?
  endLongitude Float?
  endAddress   String?

  // Calculs kilométriques
  distanceKm       Float?   @default(0) // Distance parcourue
  estimatedKm      Float? // Distance estimée initiale
  mileageRate      Float?   @default(0.50) // Taux kilométrique (€/km)
  totalCost        Float?   @default(0) // Coût total (distance * taux)
  durationMinutes  Int?     @default(0) // Durée totale en minutes

  // Justificatifs
  vehicleType        String? // Type de véhicule (voiture, moto, etc.)
  vehicleRegistration String? // Immatriculation
  hasReceipts        Boolean @default(false) // A des justificatifs (parking, péage, etc.)
  receiptAmount      Float?  @default(0) // Montant total des justificatifs

  // Relations
  checkpoints TripCheckpoint[] // Points GPS le long du trajet
  visits      Visit[] // Visites clients pendant le trajet

  // Notes et objectifs
  objective String? // Objectif du déplacement
  notes     String? // Compte-rendu du trajet
  photos    String[] @default([]) // Photos du trajet (justificatifs, etc.)

  // Validation et remboursement
  isValidated       Boolean   @default(false)
  validatedAt       DateTime?
  validatedBy       String? // UserId de l'admin/manager
  isReimbursed      Boolean   @default(false)
  reimbursedAt      DateTime?
  reimbursementAmount Float? // Montant remboursé

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([status])
  @@index([startTime])
  @@map("trips")
}

// Points GPS enregistrés le long du trajet (pour traçabilité)
model TripCheckpoint {
  id String @id @default(uuid())

  tripId String
  trip   Trip   @relation(fields: [tripId], references: [id], onDelete: Cascade)

  // Position GPS
  latitude  Float
  longitude Float
  accuracy  Float? // Précision en mètres
  address   String?

  // Vitesse et cap (optionnel)
  speed   Float? // km/h
  heading Float? // Direction (0-360°)

  // Metadata
  timestamp DateTime @default(now())

  @@index([tripId])
  @@index([timestamp])
  @@map("trip_checkpoints")
}

// Visite client pendant un trajet
model Visit {
  id String @id @default(uuid())

  tripId String
  trip   Trip   @relation(fields: [tripId], references: [id], onDelete: Cascade)

  customerId String?
  customer   Customer? @relation(fields: [customerId], references: [id])

  status  VisitStatus  @default(PLANNED)
  purpose TripPurpose? @default(CLIENT_VISIT)

  // Horaires de visite
  scheduledAt DateTime? // Heure prévue
  checkInAt   DateTime? // Arrivée sur site
  checkOutAt  DateTime? // Départ du site
  duration    Int? // Durée en minutes

  // Position GPS de la visite
  latitude  Float?
  longitude Float?
  address   String?

  // Détails de la visite
  contactName  String? // Personne rencontrée
  contactPhone String? // Téléphone du contact
  contactEmail String? // Email du contact

  objective String? // Objectif de la visite
  summary   String? // Compte-rendu de la visite
  outcome   String? // Résultat (vente, devis, SAV, etc.)

  // Documents et photos
  photos     String[] @default([]) // Photos de la visite
  documents  String[] @default([]) // Documents remis/reçus
  signature  String? // Signature client (base64)

  // Commandes/Devis liés
  orderId String?
  quoteId String?

  // Satisfaction client
  satisfactionScore Int? // Note de 1 à 5

  // Follow-up
  nextVisitDate DateTime?
  followUpNotes String?

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([tripId])
  @@index([customerId])
  @@index([checkInAt])
  @@index([status])
  @@map("visits")
}
